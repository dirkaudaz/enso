from Base import all

import Database.Data.Table as Database_Table
import Table.Data.Table as Materialized_Table
import Database.Data.Dialect
import Database.Data.Sql
import Database.Data.Internal.IR
from Database.Data.Sql import Sql_Type

polyglot java import java.util.ArrayList
polyglot java import java.sql.DriverManager
polyglot java import java.sql.PreparedStatement
polyglot java import java.sql.Types
polyglot java import java.lang.UnsupportedOperationException

type JDBC_Connection

    ## PRIVATE

       A Database connection using a JDBC driver.

       Allows to access tables from a database.

       Arguments:
       - java_connection: the resource managing the underlying JDBC connection.
       - dialect: the dialect associated with the database we are connected to.
    type JDBC_Connection connection_resource dialect

    ## UNSTABLE

       Accesses a table within the database, returning an object that can be
       used to create queries for that table.

       Arguments:
       - name: name of the table to access
    access_table : Text -> Database_Table
    access_table name =
        columns = this.fetch_columns name
        Database_Table.make_table this name columns

    ## Closes the connection releasing the underlying database resources
       immediately instead of waiting for them to be automatically released.

       The connection is not usable afterwards.
    close : Nothing
    close =
        Managed_Resource.finalize this.connection_resource

    ## ADVANCED

       Executes a raw query and returns the result as an in-memory Table.

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
    execute_query : Text | Sql.Statement -> Materialized_Table =
    execute_query statement = Panic.recover <|
        Resource.bracket (this.prepare_statement statement) .close stmt->
            rs = stmt.executeQuery
            metadata = rs.getMetaData
            ncols = metadata.getColumnCount
            ## TODO [RW] we wrap everything in objects, in the future we may
               want to try a more performant solution for columns of numbers or
               booleans
            column_names = Vector.new ncols (ix -> metadata.getColumnName ix+1)
            column_types = Vector.new ncols (ix -> metadata.getColumnType ix+1)
            columns = column_names.map (name -> [name, ArrayList.new])
            go has_next = if has_next.not then Nothing else
                columns.map_with_index ix-> pair->
                    results = pair.second
                    typ_id = column_types.at ix
                    ## getObject handles most types by default correctly, but it
                       would cast booleans to integers
                    obj = if typ_id == Types.BOOLEAN then rs.getBoolean ix+1 else
                        rs.getObject ix+1
                    results.add obj
                go rs.next
            go rs.next
            column_vectors = columns.map (pair -> [pair.first, Vector.Vector pair.second.toArray])
            Materialized_Table.new column_vectors

    ## ADVANCED

       Executes a raw update query and returns the amount of affected rows (or 0
       if not applicable).

       Arguments:
       - query: either raw SQL code as Text or an instance of Sql.Statement
         representing the query to execute.
    execute_update : Text | Sql.Statement -> Integer
    execute_update query = Panic.recover <|
        Resource.bracket (this.prepare_statement query) .close stmt->
            result = Panic.recover stmt.executeLargeUpdate
            result.catch err-> case err of
                Polyglot_Error exc ->
                    case Java.is_instance exc UnsupportedOperationException of
                        True ->
                            stmt.executeUpdate
                        False -> Error.throw err
                _ -> Error.throw err

    ## PRIVATE
    prepare_statement : Text | Sql.Statement -> Prepared_Statement
    prepare_statement query =
        go template holes=[] = Managed_Resource.with this.connection_resource java_connection->
            stmt = java_connection.prepareStatement template
            setup_error = Panic.recover <|
                holes.map_with_index ix-> obj->
                    position = ix + 1
                    case obj.first of
                        Nothing -> stmt.setNull position obj.second.typeid
                        _ -> stmt.setObject position obj.first
            setup_error.catch error->
                stmt.close
                Panic.throw error
            stmt
        Panic.recover <| case query of
            Text -> go query []
            Sql.Statement _ ->
                compiled = query.prepare
                go compiled.first compiled.second

    ## PRIVATE
    # fetch_columns : Text -> Vector [Text, Sql_Type]
    fetch_columns table_name =
        query = IR.Select_All (IR.make_ctx_from table_name)
        compiled = this.dialect.generate_sql query
        Resource.bracket (this.prepare_statement compiled) .close stmt->
            rs = stmt.executeQuery
            metadata = rs.getMetaData
            ncols = metadata.getColumnCount
            resolve_column ix =
                name = metadata.getColumnName ix+1
                typ = metadata.getColumnType ix+1
                [name, Sql_Type typ]
            Vector.new ncols resolve_column

## An error indicating that a supported dialect could not be deduced for the
   provided URL.
type UnsupportedDialect url

## PRIVATE

   Creates a JDBC connection based on a URL and optionally username and
   password.
create_jdbc_connection : Text -> Nothing | Text -> Nothing | Text -> JDBC_Connection
create_jdbc_connection url user=Nothing password=Nothing =
    dialect = Dialect.supported_dialects.find (d -> url.starts_with "jdbc:"+d.name) . map_error (_ -> UnsupportedDialect url)
    java_connection = case user.is_nothing && password.is_nothing of
        True ->
            DriverManager.getConnection url
        False ->
            DriverManager.getConnection url user password
    resource = Managed_Resource.register java_connection here.close_connection
    JDBC_Connection resource dialect

## PRIVATE
close_connection connection =
    connection.close
