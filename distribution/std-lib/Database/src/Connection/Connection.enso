from Base import all
import Database.Data.Table as Database_Table
import Table.Data.Table as Materialized_Table
import Database.Data.Sql
polyglot java import java.util.ArrayList
polyglot java import java.sql.Types

type Connection

    ## UNSTABLE

       A Database connection.

       Allows to access tables from a database.
    type Connection internal_connection

    ## UNSTABLE

       SQL dialect that the database associated with that connection is using.
    dialect : String
    dialect = this.internal_connection.dialect

    ## UNSTABLE

       Accesses a table within the database, returning an object that can be
       used to create queries for that table.

       Arguments:
       - name: name of the table to access
    access_table : Text -> Database_Table
    access_table name =
        columns = this.internal_connection.fetch_columns name
        Database_Table.make_table this name columns

    explain_query_plan : Sql.Statement -> Text
    explain_query_plan statement =
        _ = statement
        Error.throw "TODO"

    ## PRIVATE
    prepare_statement : Text | Sql.Statement -> PreparedStatement
    prepare_statement statement = case statement of
        Text -> this.internal_connection.prepare_statement statement []
        Sql.Statement _ ->
            compiled = statement.prepare
            this.internal_connection.prepare_statement compiled.first compiled.second

    ## ADVANCED
    execute_query : Text | Sql.Statement -> Materialized_Table =
    execute_query statement = Panic.recover <|
        prep_stmt = this.prepare_statement statement
        java_rs = prep_stmt.executeQuery
        metadata = java_rs.getMetaData
        ncols = metadata.getColumnCount
        ## TODO [RW] we wrap everything in objects, in the future we may want to
           try a more performant solution for columns of numbers or booleans
        column_names = Vector.new ncols (ix -> metadata.getColumnName ix+1)
        column_types = Vector.new ncols (ix -> metadata.getColumnType ix+1)
        columns = column_names.map (name -> [name, ArrayList.new])
        go has_next = if has_next.not then Nothing else
            columns.map_with_index ix-> pair->
                results = pair.second
                typ_id = column_types.at ix
                 # getObject handles most types by default correctly, but it would cast booleans to integers
                obj = if typ_id == Types.BOOLEAN then java_rs.getBoolean ix+1 else
                    java_rs.getObject ix+1
                results.add obj
            go java_rs.next
        go java_rs.next
        column_vectors = columns.map (pair -> [pair.first, Vector.Vector pair.second.toArray])
        Materialized_Table.new column_vectors

    ## ADVANCED
    execute_update : Text | Sql.Statement -> Integer
    execute_update statement = Panic.recover <|
        prep_stmt = this.prepare_statement statement
        # TODO we may want to use executeLargeUpdate but it seems to not be implemented by default (checked that it does throw)
        # we may try every time to call large update and if it fails, fall back to normal update
        prep_stmt.executeUpdate
